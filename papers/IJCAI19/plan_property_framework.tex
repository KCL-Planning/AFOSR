\section{Plan-Property Dependency Framework}

In this section, we make minimal assumptions on the planning context
and the plan properties concerned. This serves to identify the generic
structure of our framework and targeted explainability problems, which
can then be instantiated against concrete planning formalisms and
plan-property languages of interest.

We assume some formalism defining planning \defined{tasks} \task. We
do not need to make any assumptions about \task, except that it
induces a set \plans\ of \defined{plans} of interest. A ``plan''
$\plan \in \plans$ here is any structure that serves as a
specification what to do (\eg\ a sequence or partially ordered set of
actions).
%
% Joerg: not really needed after all.
%
%% For the purpose of our discussions, we assume that computing
%% \plans\ from \task\ is hard: deciding whether or not \plans\ is empty
%% is at least \np-hard, and in general $|\plans|$ is not polynomially
%% bounded in the size of \task. Our framework remains valid if these
%% assumptions are not met (\eg\ in tractable special cases of planning),
%% but canonically our explainability analyses are relevant if \plans\ is
%% large and/or hard to compute.

For our analyses to make sense, \plans\ should be the set of plan
\emph{candidates} that a human user could consider. Canonically, this
includes all action sequences that are applicable at an initial state
and that achieve a set of \defined{hard} goals/constraints -- in
general: \defined{plan properties}, see below -- which the user is not
willing to forego under any circumstance. Within \plans, then, the
questions are a) in which manner these hard plan properties are
achieved, and/or b) which other \defined{soft} properties are
achieved. We will be using the distinction between hard and soft plan
properties in some discussions, and in parts of our experiments. Keep
in mind though that, through a), our framework is not limited to
oversubscription planning; \eg\ in classical planning \plans\ can
simply be the set of (cost-optimal) plans achieving the goal, where
our framework answers questions about the properties of such plans.



\subsection{Plan Properties and Property Entailment}

Plan properties, in their most general form, are simply functions
mapping a plan to a Boolean value indicating whether or not the
property is satisfied:

\begin{definition}[Plan Property]
Denoting by \alltasks\ the set of all tasks and by \allplans\ the set
of all plans, a \emph{plan property} is a partial function $\prop :
\alltasks \times \allplans \mapsto \{\true, \false\}$. Given a task
\task\ and induced set of plans \plans, we say that \prop\ is a plan
property for \task\ if its domain includes $\{(\task,\plan) \mid \plan
\in \plans\}$.
\end{definition}

Example plan properties are goal facts/goal formulas (true at end of
plan?), temporal plan trajectory constraints, deadlines, bounds on
resource consumption, etc. For all practical purposes the authors can
think of, $\prop$ should be computable in time polynomial in the size
of its input, \ie\ it should be efficiently decidable whether ot not a
plan property is satisfied, but for the purpose of the following
definitions that restriction is not necessary.

In what follows, we asssume a task \task\ and set of plans \plans, and
we assume a set \props\ of plan properties for \task\ and \plans\ as
part of our input. In this context, another distinction not necessary
for our generic definitions, but that makes sense in practice, is that
between \defined{atomic} vs.\ \defined{composed} plan properties. The
former are given explicitly in an input file, the vanilla setup. In
more complex setups, the input is a set \propsatom\ of atomic
properties plus a specification how these can be combined into
composed properties \propscomp. For example, one may specify
\propscomp\ to be formulas over the atoms \propsatom, formed with a
given set of composition operators. In particular, the set $\props =
\propsatom \cup \propscomp$ whose dependencies are being analyzed may
be exponentially large in the size of the user input.

As a concrete instance we will consider later on, the user may be
interested in a set $G$ of soft-goal facts, where for each $g \in G$
being or not being achieved by a plan $\plan \in \plans$ is an atomic
goal property. But the interesting dependencies may be, not across
individual $g$, but over conjunctions thereof (\eg\ if conjunctions,
but not typically singletons, exclude the possibility to achieve other
goals). The input to our analysis then is merely the set $G$, while
the analysis considers dependencies across all conjunctions over $G$.

The kind of dependency our framework focusses on is entailment over
plan properties, in the space of truth-value assignments induced by
the plan-candidate set \plans:

\begin{definition}[Entailment]
Let \task\ be a task with induced set of plans \plans. Let \props\ be
a set of plan properties for \task.

Let $\plan \in \plans$. We identify \plan\ with the truth-value
assignment $\plan : \props \mapsto \{\true, \false\}$ where
$\plan(\prop) := \prop(\task,\plan)$. We identify \plans\ with the set
of such truth-value assignments. We say that
\plan\ \defined{satisfies} \prop, written $\plan \models \prop$, if
$\plan(\prop) = \true$. We denote by $\modelsof{\plans}{\prop} :=
\{\plan \mid \plan \in \plans, \plan \models \prop\}$ the models of
\prop. We say that \prop\ is \defined{satisfiable} in \plans\ if
$\modelsof{\plans}{\prop} \neq \emptyset$.

We say that \prop\ \defined{entails} \propq\ in \plans, written
$\implies{\plans}{\prop}{\propq}$, if $\modelsof{\plans}{\prop}
\subseteq \modelsof{\plans}{\propq}$.
%
We say that \prop\ and \propq\ are \defined{equivalent} in \plans,
written $\iff{\plans}{\prop}{\propq}$, if $\modelsof{\plans}{\prop} =
\modelsof{\plans}{\propq}$. The subset of \props\ equivalent with
\prop\ in \plans\ is written $\equiv{\plans}{\prop} := \{\propq \mid
\propq \in \props, \iff{\plans}{\prop}{\propq}\}$.
\end{definition}

This definition essentially just views plans $\plan \in \plans$ as
truth-value assignments in the obvious manner. Entailment and
equivalence are then defined straightforwardly, with \plans\ in the
role traditionally taken by a knowledge base that restricts the
truth-value assignments under consideration.

Importantly, the role of \plans\ as a knowledge base means that
entailment in \plans\ is more than standard entailment: the latter
implies the former, but not vice versa. As a simple example, say the
plan properties \props\ are propositional formulas $\phi$ over facts,
evaluated at the end of the plan. Then $\phi \Rightarrow \psi$ implies
that $\implies{\plans}{\phi}{\psi}$, simply because any (plan-end)
state that satisfies $\phi$ must satisfy $\psi$. But not vice versa:
\eg\ if facts $p, q$ are mutex in the task then
$\implies{\plans}{p}{\neg q}$. As a more motivating example, say the
plan properties are goals (like having scientific observations in
satellite planning) as well as resource constraints (like consuming at
most a given amount of energy). Then entailments of interest can take
the form $\implies{\plans}{p}{\neg q_1 \vee \neg q_2 \vee \neg q_3}$
saying that we cannot have $p$ without foregoing either of $q_1$ or
$q_2$ or $q_3$. Note that this is an entailment specific to \plans,
which may not hold in general (\eg\ if cheaper actions are available,
or if cheaper plans are admitted as some other hard goals for
\plans\ are removed). It is precisely the identification of such
specific entailments -- specific to the space \plans\ of plan
candidates suiting the user's hard constraints -- that motivates our
approach.





\subsection{Plan-Space Explanation}

Our plan-space explanation problems consist in identifying the
entailment relation on \props\ given the knowledge base \plans:

\begin{definition}[PDO and PDA]
Let \task\ be a task with induced set of plans \plans. Let \props\ be
a set of plan properties for \task.

The \defined{plan-property dependency order (PDO)} for \plans\ is the
partial order $\pdo{\plans}$ over the equivalence classes
$\equiv{\plans}{\prop}$, where $\equiv{\plans}{\prop} \pdo{\plans}
\equiv{\plans}{\propq}$ iff $\implies{\plans}{\prop}{\propq}$.

A set $\pda{\plans} \subseteq \props$ is a \defined{plan-property
  dependency axiomatization (PDA)} for \plans\ if, for every minimal
element $\equiv{\plans}{\prop}$ of $\pdo{\plans}$ when restricted to
\prop\ satisfiable in \plans, $\pda{\plans}$ contains exactly one
member of $\equiv{\plans}{\prop}$.
\end{definition}

We refer by the \defined{PDO problem} to the computational problem of
computing the PDO given \task\ as well as (compact) specifications of
\plans\ and \props. Accordingly for the \defined{PDA problem}.

The PDO is a plan-space explanation in the sense of making explicit
how the plan properties of interest depend on each other -- saying
things like ``we cannot have $p$ without foregoing either of $q_1$ or
$q_2$ or $q_3$''. The PDO is exhaustive, and in that sense the ideal
plan-space explanation in principle. In practice though its size may
be problematic. If one is interested in atomic plan properties only,
specified explicitly in the user input, then \props\ and hence the PDO
is small. If \props\ includes composed properties however, like
arbitrary propositional formulas, then showing the user a PDA may be
more suitable than showing the entire PDO.

A PDA captures the strongest properties, that together entail all
other properties given \plans\ -- and that, in this sense, form an
axiomatization for \plans. Unsatisfiable properties are not of
interest here as they trivially entail everything. For example, in
oversubscription planning, when plan properties are conjunctions of
soft goals, larger conjunctions entail smaller ones and a PDA
specifies the maximal solvable conjunctions.

%% We remark that the PDO is a meet-semilattice if $\props$ is closed
%% under conjunction, \ie, for every satisfiable $p, q \in \props$ there
%% is a satisfiable $r \in \props$ which is true if both $p$ and $q$ are
%% true. In this case, the PDA is a single plan property ... JOERG:
%% whatever. not gonna happen/who cares.
%
%% \joerg{reg lattices: $O$ is a ``meet-semilattice'' if $\Phi$ is closed
%%   under conjunction: in a lattice, every two elements need to have a
%%   common ancestor. in standard logic, entailment over formula
%%   equivalence classes is a lattice because for any $\phi$ and $\psi$
%%   $\phi \wedge \psi$ is a common ancestor; actually a bounded lattice,
%%   with a unique element that is an ancestor to (that implies)
%%   everything else. the same is true here if $\Phi$ is closed under
%%   conjunction (because if each of $\phi$ and $\psi$ is valid, then so
%%   is $\phi \wedge \psi$). In this case, the PDA is the unique common
%%   ancestor, which can basically be thought of as a conjunction of
%%   axioms. In lattice terminology, the unique common ancestor is called
%%   a ``least element'', ``minimum'', or ``bottom'' element; but I think
%%   none of these names makes much sense in our context so I would leave
%%   it at the above definition, maybe briefly remarking here that $O$ is
%%   a meet-semilattice if $\Phi$ is closed under conjunction.}


%% \joerg{discuss finiteness; discuss complexity (corresponds to proving
%%   unsolability in classical planning), point out encouraging results
%%   with goal-fact dependencies in our experiments.}
%
%% \joerg{think through different planning frameworks, in particular ones
%%   with continous phenomena, like time; everything below remains
%%   finite; what becomes harder or undecidable though is checking
%%   plan-property dependencies. probably discuss this below.}
%
Apropos size, some words are in order regarding
computation. Obviously, testing satisfiability of a plan property
encompasses the plan existence problem. The same is true for
plan-property entailment, where proving that an entailment
$\implies{\plans}{\prop}{\propq}$ holds corresponds to proving a
planning task unsolvable (there exists no plan that satisfies
\prop\ and that does not satisfy \propq). This is exacerbated by the
potentially exponential size of the PDO if composed plan properties
should be considered. Certainly, both the PDO and PDA problems should
ideally be solved offline, prior to interaction with a user. 

In terms of finiteness, matters are less bleak. If only atomic plan
properties are considered, the PDO is finite simply as the number of
truth-value assignments is. In the presence of an infinite set of
composed plan properties (such as propositional formulas), the PDO may
still be finite due to considering equivalence classes. In particular,
the latter is necessarily the case if the set of plans \plans\ of
interest is finite (as is the case \eg\ if the action set is finite
and plan size can be finitely bounded), because then there is only a
finite number of non-equivalent plan properties.




\joerg{add definition and discussion of ``derivability'' (or some
  such) across PDAs, where PDA for $\Phi_B$ can be derived from PDA
  for $\Phi_A$ as in our two different goal-fact dependenciues in the
  next section. ... discuss reduction to ie PDG/A for props B by
  f(PDG/A for props A) where f polytime in size of input (composed
  case: also input ie poly in size of large PDG)}




\joerg{discuss relation to model checking here somewhere? discuss
  possibility to automatically identify relevant $F$ and $\Phi$?}
